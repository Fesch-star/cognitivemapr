---
title: "evaluation step mystery"
author: "Femke van Esch"
date: "2023-07-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

Made this document to explain what goes wrong with the Evaluation_step function when put through a for loop. I cannot figure out what goes wrong.

first install the package

```{r}
#install.packages("devtools")

devtools::install_github('https://github.com/Fesch-star/cognitivemapr')
help( ,"cognitivemapr")
```



First I make some test data.

```{r}
#nodelist:
id <- c(1:5)
node_name <- c("a","b","c","d","e")
eco <- c("Ordoliberal", NA, NA, NA, "Keynesian")
Int <- c("Supranational", NA, "Intergovernmental", NA, NA)
value <- c(1,1,-1,1,1)

test_nodes <- data.frame(id, node_name, eco, Int,value)

#edgelist:
from <- c(1,3,4,2)
to <- c(3,4,5,4)
weight <- c(1,1,1,1)
edge_value <- c(1,-1,-1,1)
map_id <- c(22:25)
map_date <- c("20-5-2010", "21-5-2010","22-5-2010","23-5-2010")
value.x <- c(1,-1,1,1)
value.y <- c(-1,1,1,1)

test_edges <- data.frame(from, to, weight, edge_value, map_id, map_date,value.x, value.y)
```

We run the calculate_degrees function on the test data

```{r}
test_node_calc <- cognitivemapr::calculate_degrees(test_edges, test_nodes)
```

then we call the last version of the evaluation_step function 
then let's run the evaluation_step function on the data 3 times manually. Every time taking the output of the previous iteration as our input 

```{r}
test_edge1 <- cognitivemapr::evaluation_step(test_edges, test_node_calc)[[1]]
test_node1 <- cognitivemapr::evaluation_step(test_edges, test_node_calc)[[2]]

test_edge2 <- cognitivemapr::evaluation_step(test_edge1, test_node1)[[1]]
test_node2 <- cognitivemapr::evaluation_step(test_edge1, test_node1)[[2]]

test_edge3 <- cognitivemapr::evaluation_step(test_edge2, test_node2)[[1]]
test_node3 <- cognitivemapr::evaluation_step(test_edge2, test_node2)[[2]]
```

Let's look at the results per iteration, which are summed up in the val_run1 column of the nodelists, but correspond accurately with the last two columns of each of the edgelists. They are also stored in the last three columns of the final nodelist (test_node3). I am not sure why, because the function should override column 14 in each iteration with the new val_run1 scores. Maybe this provides a clue as what goes wrong? But I do not know how, because the calculations are based on the edgelist, which shows the correct output everytime.

Showing the values that the function should spit out after each iteration:

```{r}
test_node1$val_run1
test_node2$val_run1
test_node3$val_run1
```
Showing that in fact, the edgelist behaves as it should:

```{r}
test_edge1 [, c(1,2,7,8)]
test_edge2 [, c(1,2,7,8)]
test_edge3 [, c(1,2,7,8)]
```

Now let's test the last version of the evaluate concepts function in which Jelle included the loop, equating the maximum nr of iterations to the diameter of the CM
I get an error when trying to run this automatically "Error: 'evaluate_concepts' is not an exported object from 'namespace:cognitivemapr'"
So lets do this in the oldfashion way, and call the function manually and then run it

first let's see if set iterations works okay, does not seem to do so. The set iterations function is also not found, so I load it manually.
```{r}
iterations <- set_iterations(test_edges, test_node_calc)
iterations

result_list <- vector("list", iterations)
rm(result_list)
```
This does return 3, which is correct, and the first step in evaluate concepts also creates an empty list of 3, which is correct

```{r}

result_list <-  evaluate_concepts(test_edges, test_node_calc)

```

The loop runs and does all 3 iterations. But now let's look at the results. Let's take the val_run column of the nodelists that is returned after each iteration. Which shows that although 3 edgelists and 3 nodeslist have been returned so 3 iterations have been made), the calculations now work!! I display the results of each run, with the results of the manual runs in between. The pair of rows show the same result. Yeah!

```{r}
result_list[[1]][[2]][,"val_run1"]
test_node1$val_run1

result_list[[2]][[2]][,"val_run1"]
test_node2$val_run1

result_list[[3]][[2]][,"val_run1"]
test_node3$val_run1

```
