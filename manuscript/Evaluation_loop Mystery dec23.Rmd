---
title: "evaluation step mystery"
author: "Femke van Esch"
date: "2023-07-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

Made this document to explain what goes wrong with the Evaluation_step function when put through a for loop. I cannot figure out what goes wrong.

first install the package

```{r}
#install.packages("devtools")

devtools::install_github('https://github.com/Fesch-star/cognitivemapr')
help( ,"cognitivemapr")
```



First I make some test data.

```{r}
#nodelist:
id <- c(1:5)
node_name <- c("a","b","c","d","e")
eco <- c("Ordoliberal", NA, NA, NA, "Keynesian")
Int <- c("Supranational", NA, "Intergovernmental", NA, NA)
value <- c(1,1,-1,1,1)

test_nodes <- data.frame(id, node_name, eco, Int,value)

#edgelist:
from <- c(1,3,4,2)
to <- c(3,4,5,4)
weight <- c(1,1,1,1)
edge_value <- c(1,-1,-1,1)
map_id <- c(22:25)
map_date <- c("20-5-2010", "21-5-2010","22-5-2010","23-5-2010")
value.x <- c(1,-1,1,1)
value.y <- c(-1,1,1,1)

test_edges <- data.frame(from, to, weight, edge_value, map_id, map_date,value.x, value.y)
```

We run the calculate_degrees function on the test data

```{r}
test_node_calc <- cognitivemapr::calculate_degrees(test_edges, test_nodes)
```

then we call the last version of the evaluation_step function 
then let's run the evaluation_step function on the data 3 times manually. Every time taking the output of the previous iteration as our input 

```{r}
test_edge1 <- cognitivemapr::evaluation_step(test_edges, test_node_calc)[[1]]
test_node1 <- cognitivemapr::evaluation_step(test_edges, test_node_calc)[[2]]

test_edge2 <- cognitivemapr::evaluation_step(test_edge1, test_node1)[[1]]
test_node2 <- cognitivemapr::evaluation_step(test_edge1, test_node1)[[2]]

test_edge3 <- cognitivemapr::evaluation_step(test_edge2, test_node2)[[1]]
test_node3 <- cognitivemapr::evaluation_step(test_edge2, test_node2)[[2]]
```

Let's look at the results per iteration, which are summed up in the val_run1 column of the nodelists, but correspond accurately with the last two columns of each of the edgelists. They are also stored in the last three columns of the final nodelist (test_node3). I am not sure why, because the function should override column 14 in each iteration with the new val_run1 scores. Maybe this provides a clue as what goes wrong? But I do not know how, because the calculations are based on the edgelist, which shows the correct output everytime.

Showing the values that the function should spit out after each iteration:

```{r}
test_node3[, c(14,15,16)]
```
Showing that in fact, the edgelist behaves as it should:

```{r}
test_edge1 [, c(1,2,7,8)]
test_edge2 [, c(1,2,7,8)]
test_edge3 [, c(1,2,7,8)]
```

Now let's test the last version of the evaluate concepts function in which Jelle included the loop, equating the maximum nr of iterations to the diameter of the CM
I get an error when trying to run this automatically "Error: 'evaluate_concepts' is not an exported object from 'namespace:cognitivemapr'"
So lets do this in the oldfashion way, and call the function manually and then run it

```{r}
test_edge_all <- evaluate_concepts(test_edges, test_node_calc)[[1]]
test_node_all <- evaluate_concepts(test_edges, test_node_calc)[[2]]
```

The loop runs and does all 3 iterations. But now let's look at the results. Let's take the val_run column of the nodelists that is returned after each iteration. Which shows that although 3 edgelists and 3 nodeslist have been returned, and in the Environment i has run up to 3 (so 3 iterations should have been made), the calculations seem to get stuck at the first iteration (the calculations are done in that first step, because val_run1 does not exist as a column in the original node_calc_data frame.

```{r}
result_list[[1]][[2]][,"val_run1"]
result_list[[2]][[2]][,"val_run1.y"]
result_list[[3]][[2]][,"val_run1.x"]

```
I have stared at this for hours now, and I cannot figure out what goes wrong :( Help!


Below is superfluous stuff that I want to keep

```{r}
# Access the results for each run
for (i in max_runs) {
  edgelist_result <- result_list[[i]][[1]]
  nodelist_result <- result_list[[i]][[2]]

# Perform any additional actions or analysis on edgelist_result and nodelist_result here

  edgelist_result <- result_list[[i]][[i]]
}
```


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
