---
title: "evaluation step mystery"
author: "Femke van Esch"
date: "2023-07-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

Made this document to explain what goes wrong with the Evaluation_step function when put through a for loop. I cannot figure out what goes wrong.

first install the package

```{r}
#install.packages("devtools")

devtools::install_github('https://github.com/Fesch-star/cognitivemapr')
help( ,"cognitivemapr")
```



First I make some test data.

```{r}
#nodelist:
id <- c(1:5)
node_name <- c("a","b","c","d","e")
eco <- c("Ordoliberal", NA, NA, NA, "Keynesian")
Int <- c("Supranational", NA, "Intergovernmental", NA, NA)
value <- c(1,1,-1,1,1)

test_nodes <- data.frame(id, node_name, eco, Int,value)

#edgelist:
from <- c(1,3,4,2)
to <- c(3,4,5,4)
weight <- c(1,1,1,1)
edge_value <- c(1,-1,-1,1)
map_id <- c(22:25)
map_date <- c("20-5-2010", "21-5-2010","22-5-2010","23-5-2010")
value.x <- c(1,-1,1,1)
value.y <- c(-1,1,1,1)

test_edges <- data.frame(from, to, weight, edge_value, map_id, map_date,value.x, value.y)
```

We run the calculate_degrees function on the test data

```{r}
test_node_calc <- cognitivemapr::calculate_degrees(test_edges, test_nodes)
```

then we call the last version of the evaluation_step function 
then let's run the evaluation_step function on the data 3 times manually. Every time taking the output of the previous iteration as our input 

```{r}
test_edge1 <- cognitivemapr::evaluation_step(test_edges, test_node_calc)[[1]]
test_node1 <- cognitivemapr::evaluation_step(test_edges, test_node_calc)[[2]]

test_edge2 <- cognitivemapr::evaluation_step(test_edge1, test_node1)[[1]]
test_node2 <- cognitivemapr::evaluation_step(test_edge1, test_node1)[[2]]

test_edge3 <- cognitivemapr::evaluation_step(test_edge2, test_node2)[[1]]
test_node3 <- cognitivemapr::evaluation_step(test_edge2, test_node2)[[2]]
```

Let's look at the results per iteration, which are summed up in the val_run1 column of the nodelists, but correspond accurately with the last two columns of each of the edgelists. They are also stored in the last three columns of the final nodelist (test_node3). I am not sure why, because the function should override column 14 in each iteration with the new val_run1 scores. Maybe this provides a clue as what goes wrong? But I do not know how, because the calculations are based on the edgelist, which shows the correct output everytime.

Showing the values that the function should spit out after each iteration:

```{r}
test_node1$val_run1
test_node2$val_run1
test_node3$val_run1
```
Showing that in fact, the edgelist behaves as it should:

```{r}
test_edge1 [, c(1,2,7,8)]
test_edge2 [, c(1,2,7,8)]
test_edge3 [, c(1,2,7,8)]
```

Now let's test the last version of the evaluate concepts function in which Jelle included the loop, equating the maximum nr of iterations to the diameter of the CM
I get an error when trying to run this automatically "Error: 'evaluate_concepts' is not an exported object from 'namespace:cognitivemapr'"
So lets do this in the oldfashion way, and call the function manually and then run it

first let's see if set iterations works okay.
```{r}
iterations <- cognitivemapr::set_iterations(test_edges, test_node_calc)
iterations

```
This does return 3, which is correct, and the first step in evaluate concepts also creates an empty list of 3, which is correct

```{r}

result_list <-  cognitivemapr::evaluate_concepts(test_edges, test_node_calc)

```

The loop runs and does all 3 iterations. But now let's look at the results. Let's take the val_run column of the nodelists that is returned after each iteration. Which shows that although 3 edgelists and 3 nodeslist have been returned so 3 iterations have been made), the calculations now work!! I display the results of each run, with the results of the manual runs in between. The pair of rows show the same result. Yeah!

```{r}
result_list[[1]][[2]][,"val_run1"]
test_node1$val_run1

result_list[[2]][[2]][,"val_run1"]
test_node2$val_run1

result_list[[3]][[2]][,"val_run1"]
test_node3$val_run1

```

now let's run the test on Ruttep2


load the data

```{r, results='hide', warning=FALSE, message=FALSE}
library(readr)

load("../data/rutte_p2_edgelist.rda")
load("../data/rutte_p2_nodelist.rda")

```

run the calculate_degrees function

```{r}
#running the function with the data of Mark Rutte, and storing it as a df
rutte_p2_node_measures <- cognitivemapr::calculate_degrees(rutte_p2_edgelist, rutte_p2_nodelist)

```

```{r}
#run the evaluate_step function 5 times

test_edge1 <- cognitivemapr::evaluation_step(rutte_p2_edgelist, rutte_p2_node_measures)[[1]]
test_node1 <- cognitivemapr::evaluation_step(rutte_p2_edgelist, rutte_p2_node_measures)[[2]]

test_edge2 <- cognitivemapr::evaluation_step(test_edge1, test_node1)[[1]]
test_node2 <- cognitivemapr::evaluation_step(test_edge1, test_node1)[[2]]

test_edge3 <- cognitivemapr::evaluation_step(test_edge2, test_node2)[[1]]
test_node3 <- cognitivemapr::evaluation_step(test_edge2, test_node2)[[2]]

test_edge4 <- cognitivemapr::evaluation_step(test_edge3, test_node3)[[1]]
test_node4 <- cognitivemapr::evaluation_step(test_edge3, test_node3)[[2]]

test_edge5 <- cognitivemapr::evaluation_step(test_edge4, test_node4)[[1]]
test_node5 <- cognitivemapr::evaluation_step(test_edge4, test_node4)[[2]]
```


Let's look at the results
```{r}
test_node1$val_run1
test_node2$val_run1
test_node3$val_run1
test_node4$val_run1
test_node5$val_run1
```
Okay, I thought it would keep changing 5 times, but it stabilises after 2 runs

Now test the evaluate_concepts function, which has the 5 iterations built into it
```{r}
result_list <- cognitivemapr::evaluate_concepts(rutte_p2_edgelist, rutte_p2_node_measures)
```


Let's compare the results:
```{r}
# test of the current solution to running multiple iterations of the evaluate_concepts function:
# store the results of all the 5 iterations seperately
run1 <- result_list[[1]][[2]][,c("node_name","val_run1")]
run2 <- result_list[[2]][[2]][,c("node_name","val_run1")]
run3 <- result_list[[3]][[2]][,c("node_name","val_run1")]
run4 <- result_list[[4]][[2]][,c("node_name","val_run1")]
run5 <- result_list[[5]][[2]][,c("node_name","val_run1")]


# compare the results for each iteration but with true/false (why does it not compare whole lists?)

results1 = ifelse (run1$val_run1 == test_node1$val_run1, 'same', "different")
results2 = ifelse (run2$val_run1 == test_node2$val_run1, 'same', "different")
results3 = ifelse (run3$val_run1 == test_node3$val_run1, 'same', "different")
results4 = ifelse (run3$val_run1 == test_node4$val_run1, 'same', "different")
results5 = ifelse (run3$val_run1 == test_node5$val_run1, 'same', "different")

#show on screen

results1
results2
results3
results4
results5

```








